// Code generated by MockGen. DO NOT EDIT.
// Source: deps.go
//
// Generated by this command:
//
//	mockgen -source deps.go -package buying -typed -destination mock_deps_test.go
//

// Package buying is a generated GoMock package.
package buying

import (
	context "context"
	reflect "reflect"

	model "github.com/inna-maikut/avito-shop/internal/model"
	gomock "go.uber.org/mock/gomock"
)

// MocktrManager is a mock of trManager interface.
type MocktrManager struct {
	ctrl     *gomock.Controller
	recorder *MocktrManagerMockRecorder
}

// MocktrManagerMockRecorder is the mock recorder for MocktrManager.
type MocktrManagerMockRecorder struct {
	mock *MocktrManager
}

// NewMocktrManager creates a new mock instance.
func NewMocktrManager(ctrl *gomock.Controller) *MocktrManager {
	mock := &MocktrManager{ctrl: ctrl}
	mock.recorder = &MocktrManagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MocktrManager) EXPECT() *MocktrManagerMockRecorder {
	return m.recorder
}

// Do mocks base method.
func (m *MocktrManager) Do(ctx context.Context, fn func(context.Context) error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Do", ctx, fn)
	ret0, _ := ret[0].(error)
	return ret0
}

// Do indicates an expected call of Do.
func (mr *MocktrManagerMockRecorder) Do(ctx, fn any) *MocktrManagerDoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Do", reflect.TypeOf((*MocktrManager)(nil).Do), ctx, fn)
	return &MocktrManagerDoCall{Call: call}
}

// MocktrManagerDoCall wrap *gomock.Call
type MocktrManagerDoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MocktrManagerDoCall) Return(err error) *MocktrManagerDoCall {
	c.Call = c.Call.Return(err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MocktrManagerDoCall) Do(f func(context.Context, func(context.Context) error) error) *MocktrManagerDoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MocktrManagerDoCall) DoAndReturn(f func(context.Context, func(context.Context) error) error) *MocktrManagerDoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockemployeeRepo is a mock of employeeRepo interface.
type MockemployeeRepo struct {
	ctrl     *gomock.Controller
	recorder *MockemployeeRepoMockRecorder
}

// MockemployeeRepoMockRecorder is the mock recorder for MockemployeeRepo.
type MockemployeeRepoMockRecorder struct {
	mock *MockemployeeRepo
}

// NewMockemployeeRepo creates a new mock instance.
func NewMockemployeeRepo(ctrl *gomock.Controller) *MockemployeeRepo {
	mock := &MockemployeeRepo{ctrl: ctrl}
	mock.recorder = &MockemployeeRepoMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockemployeeRepo) EXPECT() *MockemployeeRepoMockRecorder {
	return m.recorder
}

// GetByIDWithLock mocks base method.
func (m *MockemployeeRepo) GetByIDWithLock(ctx context.Context, employeeID int64) (*model.Employee, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetByIDWithLock", ctx, employeeID)
	ret0, _ := ret[0].(*model.Employee)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetByIDWithLock indicates an expected call of GetByIDWithLock.
func (mr *MockemployeeRepoMockRecorder) GetByIDWithLock(ctx, employeeID any) *MockemployeeRepoGetByIDWithLockCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByIDWithLock", reflect.TypeOf((*MockemployeeRepo)(nil).GetByIDWithLock), ctx, employeeID)
	return &MockemployeeRepoGetByIDWithLockCall{Call: call}
}

// MockemployeeRepoGetByIDWithLockCall wrap *gomock.Call
type MockemployeeRepoGetByIDWithLockCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockemployeeRepoGetByIDWithLockCall) Return(arg0 *model.Employee, arg1 error) *MockemployeeRepoGetByIDWithLockCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockemployeeRepoGetByIDWithLockCall) Do(f func(context.Context, int64) (*model.Employee, error)) *MockemployeeRepoGetByIDWithLockCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockemployeeRepoGetByIDWithLockCall) DoAndReturn(f func(context.Context, int64) (*model.Employee, error)) *MockemployeeRepoGetByIDWithLockCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetByUsername mocks base method.
func (m *MockemployeeRepo) GetByUsername(ctx context.Context, username string) (*model.Employee, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetByUsername", ctx, username)
	ret0, _ := ret[0].(*model.Employee)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetByUsername indicates an expected call of GetByUsername.
func (mr *MockemployeeRepoMockRecorder) GetByUsername(ctx, username any) *MockemployeeRepoGetByUsernameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByUsername", reflect.TypeOf((*MockemployeeRepo)(nil).GetByUsername), ctx, username)
	return &MockemployeeRepoGetByUsernameCall{Call: call}
}

// MockemployeeRepoGetByUsernameCall wrap *gomock.Call
type MockemployeeRepoGetByUsernameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockemployeeRepoGetByUsernameCall) Return(arg0 *model.Employee, arg1 error) *MockemployeeRepoGetByUsernameCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockemployeeRepoGetByUsernameCall) Do(f func(context.Context, string) (*model.Employee, error)) *MockemployeeRepoGetByUsernameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockemployeeRepoGetByUsernameCall) DoAndReturn(f func(context.Context, string) (*model.Employee, error)) *MockemployeeRepoGetByUsernameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IncreaseBalance mocks base method.
func (m *MockemployeeRepo) IncreaseBalance(ctx context.Context, employeeID, amount int64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IncreaseBalance", ctx, employeeID, amount)
	ret0, _ := ret[0].(error)
	return ret0
}

// IncreaseBalance indicates an expected call of IncreaseBalance.
func (mr *MockemployeeRepoMockRecorder) IncreaseBalance(ctx, employeeID, amount any) *MockemployeeRepoIncreaseBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IncreaseBalance", reflect.TypeOf((*MockemployeeRepo)(nil).IncreaseBalance), ctx, employeeID, amount)
	return &MockemployeeRepoIncreaseBalanceCall{Call: call}
}

// MockemployeeRepoIncreaseBalanceCall wrap *gomock.Call
type MockemployeeRepoIncreaseBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockemployeeRepoIncreaseBalanceCall) Return(arg0 error) *MockemployeeRepoIncreaseBalanceCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockemployeeRepoIncreaseBalanceCall) Do(f func(context.Context, int64, int64) error) *MockemployeeRepoIncreaseBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockemployeeRepoIncreaseBalanceCall) DoAndReturn(f func(context.Context, int64, int64) error) *MockemployeeRepoIncreaseBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockinventoryRepo is a mock of inventoryRepo interface.
type MockinventoryRepo struct {
	ctrl     *gomock.Controller
	recorder *MockinventoryRepoMockRecorder
}

// MockinventoryRepoMockRecorder is the mock recorder for MockinventoryRepo.
type MockinventoryRepoMockRecorder struct {
	mock *MockinventoryRepo
}

// NewMockinventoryRepo creates a new mock instance.
func NewMockinventoryRepo(ctrl *gomock.Controller) *MockinventoryRepo {
	mock := &MockinventoryRepo{ctrl: ctrl}
	mock.recorder = &MockinventoryRepoMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockinventoryRepo) EXPECT() *MockinventoryRepoMockRecorder {
	return m.recorder
}

// AddOne mocks base method.
func (m *MockinventoryRepo) AddOne(ctx context.Context, employeeID, merchID int64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddOne", ctx, employeeID, merchID)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddOne indicates an expected call of AddOne.
func (mr *MockinventoryRepoMockRecorder) AddOne(ctx, employeeID, merchID any) *MockinventoryRepoAddOneCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddOne", reflect.TypeOf((*MockinventoryRepo)(nil).AddOne), ctx, employeeID, merchID)
	return &MockinventoryRepoAddOneCall{Call: call}
}

// MockinventoryRepoAddOneCall wrap *gomock.Call
type MockinventoryRepoAddOneCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockinventoryRepoAddOneCall) Return(arg0 error) *MockinventoryRepoAddOneCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockinventoryRepoAddOneCall) Do(f func(context.Context, int64, int64) error) *MockinventoryRepoAddOneCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockinventoryRepoAddOneCall) DoAndReturn(f func(context.Context, int64, int64) error) *MockinventoryRepoAddOneCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockmerchRepo is a mock of merchRepo interface.
type MockmerchRepo struct {
	ctrl     *gomock.Controller
	recorder *MockmerchRepoMockRecorder
}

// MockmerchRepoMockRecorder is the mock recorder for MockmerchRepo.
type MockmerchRepoMockRecorder struct {
	mock *MockmerchRepo
}

// NewMockmerchRepo creates a new mock instance.
func NewMockmerchRepo(ctrl *gomock.Controller) *MockmerchRepo {
	mock := &MockmerchRepo{ctrl: ctrl}
	mock.recorder = &MockmerchRepoMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockmerchRepo) EXPECT() *MockmerchRepoMockRecorder {
	return m.recorder
}

// GetByName mocks base method.
func (m *MockmerchRepo) GetByName(ctx context.Context, name string) (*model.Merch, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetByName", ctx, name)
	ret0, _ := ret[0].(*model.Merch)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetByName indicates an expected call of GetByName.
func (mr *MockmerchRepoMockRecorder) GetByName(ctx, name any) *MockmerchRepoGetByNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByName", reflect.TypeOf((*MockmerchRepo)(nil).GetByName), ctx, name)
	return &MockmerchRepoGetByNameCall{Call: call}
}

// MockmerchRepoGetByNameCall wrap *gomock.Call
type MockmerchRepoGetByNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockmerchRepoGetByNameCall) Return(arg0 *model.Merch, arg1 error) *MockmerchRepoGetByNameCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockmerchRepoGetByNameCall) Do(f func(context.Context, string) (*model.Merch, error)) *MockmerchRepoGetByNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockmerchRepoGetByNameCall) DoAndReturn(f func(context.Context, string) (*model.Merch, error)) *MockmerchRepoGetByNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
